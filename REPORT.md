# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Лисовский О.Р.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Главным отличием списков в языке Пролог от списков в императивных языках является, то что списки Пролога по факту являются бинарными деревьями. Вдобавок любой список либо является, либо содержит в своём конце пустой список. Так же списки в Прологе по умолчанию могут содержать любые элементы: атомы, числа, структурные термы и списки.

## Задание 1.1: Предикат обработки списка

`kill1(X,Y,Z)` - Предикат удаления всех элементов списка по значению с использованием стандартных предикатов.
`kill2(X,Y,Z)` - Предикат удаления всех элементов списка по значению без использования стандартных предикатов.
``
``
Примеры использования:
```prolog
?- kill1(t,[t,y,t,u,i],X).
X = [y, u, i].

?- kill2(h,[h,h,h,h,h,h,h,g,t,h,d,h],X).
X = [g, t, d].
```

Реализация:
```prolog

kill1(_,[],[]):-!.
kill1(K,H,TT):-rremove(K,H,T),!,kill1(K,T,TT).
kill1(_,TT,TT):-!.

kill2(_,[],[]):-!.
kill2(K,[K|T],L):-kill2(K,T,L),!.
kill2(K,[H|T],[H|L]):-kill2(K,T,L).

```

Предикат kill1 просматривает список и при просмотре элемента использует на нем предикат rremove. В случае, когда элемент совпадает с заданным то, он будет удалён из списка.

Предикат kill2 работает идентично предикату remove за исключением того, что он исключает из списка все повторяющиеся элементы.
## Задание 1.2: Предикат обработки числового списка

`merge1(X,Y,Z)` - Предикат слияния двух упорядоченных списков на стандартных предикатах.
`merge2(X,Y,Z)` - Предикат слияния двух упорядоченных списков без использования стандартных предикатов.

Примеры использования:
```prolog
?- merge1([5,7,18],[4,5,6,78],X).
X = [4, 5, 5, 6, 7, 18, 78].

?- merge2([8,88,99],[1,2,3,4],X).
X = [1, 2, 3, 4, 8, 88, 99].
```


Реализация:
```prolog
merge1([],L,L):-!.
merge1(L,[],L):-!.
merge1([H1|T1],[H2|T2],L):-H1<H2,merge1(T1,[H2|T2],YY),aappend([H1],YY,L),!.
merge1([H1|T1],[H2|T2],L):-H1>=H2,merge1([H1|T1],T2,YY),aappend([H2],YY,L).

merge2([],L,L):-!.
merge2(L,[],L):-!.
merge2([H1|T1],[H2|T2],[H1|TT]):-H1<H2,!,merge2(T1,[H2|T2],TT).
merge2(L,[H|T],[H|TT]):-merge2(L,T,TT).
```

Предикат merge1 сравнивает головы полученных списков, находит меньшую из них, после чего продолжает сравнение, но уже хвоста списка с меньшей головой с большей головой. Как только один из списков заканчивается (вместе с рекурсией), выявленные на каждом шаге минимумы и максимумы сливаются в один список.

Предикат merge2 является более рациональной версией предиката merge1, так как сразу помещает больший элемент в голову необходимого списка, устраняя надобность в предикате aappend.

## Задание 2: Реляционное представление данных

Главное преймущество реляционного представления в том, что оно позволяет удобно и компактно расположить необходимые данные и обеспечить к ним доступ. Недостатком же является возможная сложность работы с этими данными и увеличение затрачиваемой памяти.
Недостатком представления four.pl являются термы subject. Вместо них в список студентов группы можно было преобразовать из "Фамилия" к предикаму grade("Фамилия",["Список оценок"]), и оценки шли бы в определнном порядке, например 'Логическое программирование', 'Математический анализ', 'Функциональное программирование', 'Информатика', 'Английский язык', и 'Психология'.

`badsubject(X,Y)` - Предикат нахождения количества студентов, не сдавших предмет.
Он выписывает в отдельный список неудовлетворительные оценки по заданному предмету, после чего вычисляет длину этого списка.

`studmid(X,Y)` - Предикат нахождения среднего балла студента и проверка факта сдачи экзаменов.
Он создаёт список из списков оценок по каждому предмету, после чего вычисляет его длину. Затем он рекурсивно обходит этот список и для необходимого студента получат сумму его оценок. После полученная сумма оценок делится на длинну списка.

`biglist(X,Y,Z)` - Предикат просмотра и выявления суммы оценок студента в полученном списке списков.
Рекурсивно проосматревает список списков оценок. Для каждого предмета находит этого студента и его оценку, на каждом уровне рекурсии увеличивая сумму оценок и проверяя факт сдачи или несдачи студентом экзаменов.

`pass(X,Y)` - Предикат вывода сообщения о несдаче.
В случае если оценка равна 2 то печатается "Несдал"

`studmax(X,Y)` - Предикат нахождения студента с максимальным баллом в каждой группе.
Сначала составляет список списков оценок по всем предметам и вычисляет его длину. Далее составляет список сумм оценок учеников данной группы и находит в этом списке максимум, после чего печатает обладателя максимального среднего балла.

`getGradesSum(X,Y,Z)` - Предикат получения списка суммы оценок студентов.
Рекурсивно для каждого студента находит сумму его оценок, сливая их в один список

`getSum(X,Y,Z)` - Предикат получения суммы оценок студента.
Рекурсивно обходит список списков оценок вычисляя сумму оценок конкретного студента.

`findmax(X,Y)` - Предикат нахождения максимальной суммы оценок.
Рекурсивно проходится по списку, сравнивая последний найденный максимум с данным числом в списке.

`checkmax(X,Y,Z)` - Предикат нахождения максимума из двух чисел.
Сравнивает два числа и возвращает из них наибольшее.

`printStud(X,Y,Z)` - Предикат идущий по списку студентов группы с целью вывести, тех у кого наибольшая оценка.
Рекурсивно ищет в списке студентов обладающих наибольшей суммой оценок. При нахождении выводит на экран их фамилии.

`checkwrite(X,Y,Z)` - Предикат печати студента\ов с максимальной суммой оценок.
В случае совпадения суммы всех оценок данного студента с максимальной он выводится на экран. В противном случае ничего не происходит.


## Выводы

Данная лабораторная работа показала мне как выглядят списки и как с ними работать. Довольно странным первое время казался принцип работы рекурсии в Прологе. Вместо того чтобы прекратить вычисления при нахождении конца списка, их наоборот приходилось только начинать. Только во время реализации последнего предиката studmax я осознал, почему в Прологе приходится прибегать к такой "обратной" рекурсии, вдобавок осознал, что подобное довольно легко реализовать с использованием императивных языков прогроммирования. В принципе, реализовать на Прологе такую же рекурсию как на императивных языках прогроммирования возможно, но это принесёт ненужные сложности, которые изрядно увеличат время написания программы. Только предикаты merge1 и merge2 использовали рекурсию так, как она была бы реализована в императивных языках прогроммирования, но не из-за того что это редкий случай когда так удобней сделать, а из-за того что на императивных языках слияние упорядоченных списков выглядело бы точно так же: находим минимум и идем в следующий элемент списка содержащий минимум и только в процессе обратной рекурсии определяем к какой голове какой хвост присоединять.