# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Лисовский О.Р.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

В результате выполнения этого курсового проекта я должен буду научиться работе с файлами в фориате GEDCOM и их преобразованию к предикатам Пролога. Также я должен буду научиться работать с семейным деревом, представленным предикатами Пролога и научиться определять произвольную степень родства.

## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: parent(родитель, ребенок), sex(человек, m/f)
 3. Реализовать предикат проверки/поиска: двоюродный брат
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## Получение родословного дерева

Первым шагом было поговорить с мамой на кухне, чтобы записать на бумаге всех родственников, что мы с ней знаем, для того чтобы никого не забыть. Далее по полученным чертежам дерево было построено в программе GenoPro. Всего в этом дереве, включая автора данной курсовой работы, 39 человек. После этого дерево было конвертированно с помощью встроенной функции в формат GEDCOM.

## Конвертация родословного дерева

Для преобразования файла в формате GEDCOM к предикатам Пролога, я использовал язык Си, так как хорошо его знаю и достаточно сильно к нему привык. Поскольку в GEDCOM файле изначально идут id индивидов то программа прогоняет файл вплоть до встречи знака @. После в id нового индивида записывается 10 следующих за @ знаков. Затем в имя данного члена семьи записывается то что идет за словом DISPLAY, так как в строке NAME фамилия содержит лишние символы.

`while (tmp != '\n' && tmp !='\0')//чтение имени

{

	person[count].name[inPersonCount] = tmp;
	
	inPersonCount++;
	
	tmp = fgetc(ged);
	
}`

Позиции givn, middle, surn, position и boundaryrect пропускаются так как не имеют смысла. Позиция SEX заносится в пол человека с понижением регистра.

`while (tmp != 'F' && tmp != 'M')//пропуск слова sex

{

	tmp = fgetc(ged);
	
}

tmp = tmp + 32;//понижение регистра

person[count].sex = tmp;`

После считывания всех членов семьи программа начинает расставлять связи типа родители дети. Считывается id мужа после чего он находится в списке членов семьи, такие же действия совершаются в отношении жены. Далее считывается id ребёнка, он так же находится в списке людей и ссылка на этот ребёнок добавляется в динамический массив детей при жене и муже.

`for (inPersonCount = 0; inPersonCount < count; inPersonCount++)//нахождение ребёнка в списке людей

{

	if (strncmp(tmpId, person[inPersonCount].id, 10) == 0)

	{

		person[husband].children++;

		person[wife].children++;

		person[husband].child = (TPerson*)realloc(person[husband].child, person[husband].children * sizeof(TPerson));

		person[wife].child = (TPerson*)realloc(person[wife].child, person[wife].children * sizeof(TPerson));

		person[husband].child[person[husband].children - 1] = person[inPersonCount];

		person[wife].child[person[wife].children - 1] = person[inPersonCount];

	}

}`

После нахождения всех родственных связей GEDCOM файл закрывается и полученный массив людей выводится в консоль.

`for (inPersonCount = 0; inPersonCount < count; inPersonCount++)//печать пола человека и его детей
{
	printf("sex(\"%s\",%c).\n", person[inPersonCount].name, person[inPersonCount].sex);
	for (childCounter = 0; childCounter < person[inPersonCount].children; childCounter++)
	{
		printf("parent(\"%s\",\"%s\").\n", person[inPersonCount].name, person[inPersonCount].child[childCounter].name);
	}
	free(person[inPersonCount].child);//заранее освобождаем выделенную на детей память
}`

## Предикат поиска родственника

Опишите, как устроен предикат поиска родственника, приведите его исходный код и примеры запросов/ответов (протокол работы).

Поиск двоюродного брата осуществляется следующим образом: проверяется пол искомого человека, после чего программа ищет родителей этих двух человек, после чего находит общего отца найденных родителей, дополнительно проверяется факт того что запрошенные люди не один человек и что они не братья.

`cousin_male_in_first_generation(Man,Cousin):-sex(Cousin,m),parent(Parent1,Man),parent(Parent2,Cousin),father(Parent1,Father),father(Parent2,Father),not(Man = Cousin),not(brother(Man,Cousin)).`

`?- cousin_male_in_first_generation("Ирина Валерьевна Коноплёва",X).

X = "Владислав Александрович Коноплёв" ;

X = "Никита Александрович Коноплёв" ;

false.

?- cousin_male_in_first_generation(X,"Роман Михайлович Лисовский").

X = "Марина Александровна Лазарева" ;

false.

?- cousin_male_in_first_generation("Елена Владимировна Лисовская","Валерий Владимирович Коноплёв").

true ;

false.`

## Определение степени родства

Поочерёдно перебираются варианты, когда эти два индивида являются друг другу родителями, матерями, отцами, братьями, сестрами, сыновьями, дочерьми, дедушками, бабушками, двоюродными братьями, внучками, и внуками. Во всех случаях проверяется, не являются ли они одними и теми же людьми.

`relative(Relationship,Man1,Man2):-(parent(Man1,Man2),Relationship = parent, not(Man1 = Man2));(mother(Man1,Man2),Relationship = mother, not(Man1 = Man2));(father(Man1,Man2),Relationship = father, not(Man1 = Man2));(brother(Man1,Man2),Relationship = brother, not(Man1 = Man2));(sister(Man1,Man2),Relationship = sister, not(Man1 = Man2));(son(Man1,Man2),Relationship = son, not(Man1 = Man2));(daughter(Man1,Man2),Relationship = daughter, not(Man1 = Man2));(grandfather(Man1,Man2),Relationship = grandfather, not(Man1 = Man2));(grandmother(Man1,Man2),Relationship = grandmother, not(Man1 = Man2));(cousin_male_in_first_generation(Man1,Man2),Relationship = cousin_male_in_first_generation, not(Man1 = Man2));(granddaughter(Man1,Man2),Relationship = granddaughter, not(Man1 = Man2));(grandson(Man1,Man2),Relationship = grandson, not(Man1 = Man2)).`

`?- relative(X,"Борис Иванович Коноплёв","Елена Владимировна Лисовская").

X = granddaughter ;

false.

?- relative(X,"Олег Романович Лисовский","Ольга Борисовна Киселёва").

X = grandmother ;

false.

?- relative(cousin_male_in_first_generation,X,"Олег Романович Лисовский").

X = "Дарья Владимировна Шведова" ;

X = "Анна Владимировна Шведова" ;`

Приведите описание метода решения, важные фрагменты исходного кода, протокол работы.

## Естественно-языковый интерфейс

## Выводы

При выполнении данной курсовой работы я научился составлять и обрабатывать семейное дерево. Я научился создавать различные предикаты проверки родства и предикат определения степени родства. Я научился сводить файл в GEDCOM формате к предикатам Пролога. Именно при выполнении данной курсовой работы я научился составлять предикаты разной сложности при помощи минимально заданного их начального количества. Я понял что потенциально любая родственная связь, при наличии необходимой усидчивости, может быть записана при помощи предикатов Пролога. Так же при добавлении новых членов семьи в дерево будет достаточно записать то как эти индивидуумы будут связаны при помощи базовых предикатов.
