#№ Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Лисовский О.Р.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Решение логических задач всегда сводится к сбору всех фактов и их упорядочеванию. Одним из самых популярных методов решения логических задач  является принятие какого либо факта всегда верным или всегда ложным, после чего относительно него проверяются остальные факты. Если получается что при всегда верном или всегда ложном факте верного решения нет, то полагается что данный факт всегда имеет противоположное значение, после чего данная цепочка действий проделывается с другим фактом. В случае же нахождения правильного ответа процесс решения либо прекращается, либо продолжается влоть до нахождения других возможных решений, либо установления что их больше нет.
Prolog удобен для решения таких задач, так как в нем главное - это правильно записать все имеющиеся факты и в верном порядке определить проверку этих фактов, если потребуется то наложить дополнительные условия, которые являются чисто техническими. И зачастую это даже проще чем решать туже задачу на бумаге.

## Задание

6 человек назовем их А, Б, В, Г, Д и Е кандидаты посты председателя, заместителя председателя и секретаря правления общества любителей логических задач. Но определить состав этой тройки оказалось не так-то легко. Судите сами: А не хочет входить в состав руководства, если Д не будет председателем. Б не хочет входить в состав руководства, если ему придется быть старшим над В. Б не хочет работать вместе с Е ни при каких условиях. В не хочет работать, если в состав руководства войдут Д и Е вместе. В не будет работать, если Е будет председателем, или если Б будет секретарем. Г не будет работать с В или Д, если ему придется подчиняться тому или другому. Д не хочет быть заместителем председателя. Д не хочет быть секретарем, если в состав руководства войдет Г. Д не хочет работать вместе с А, если Е не войдет в состав руководства. Е согласен работать только в том случае, если председателем будет либо он, либо В. Как они решили эту проблему? .

## Принцип решения

Прежде всего программа сводит список всех шести кандидатов к списку должностей, так чтобы один и тот же человек не присутствовал несколько раз. 
getThree(L),not(willNotA("А",L)),not(willNotB("Б",L)),not(willNotV("В",L)),not(willNotG("Г",L)),not(willNotD("Д",L)),not(willNotE("Е",L)).
После этот список проходит проверку относительно всех шести кандидатов, причем человек будет несогласен входить в состав руководства не только если не выполняются его условия но и если он попал в заготовленный на первом шаге список.
willNotA("А",[X|T]):-X\="Д",member("А",[X|T]).
willNotD("Д",[_,"Д",_]).
Если хотя бы один человек из списка несогласен, то составляется новый список и вновь начинается проверка относительно заданных людьми условий. Когда же выявлен правильный список руководства, то он подаётся предикату show для удобства понимания того, кто занял определённую должность.
show([X,Y,Z]):-write("Председатель - "),writeln(X),write("Заместитель председателя - "),writeln(Y),write("Секретарь - "),writeln(Z).

```prolog
?- solve([X,Y,Z]).
Председатель - В
Заместитель председателя - Б
Секретарь - Д
X = "В",
Y = "Б",
Z = "Д" ;
false.
```

Алгоритмическая сложность данной задачи - экспоненциальная.

## Выводы

При выполнении данной лабораторной работы я научился тому как с помощью Prolog решать логические задачи. Так же она научила меня рассматривать все возможные варианты написания предикатов, возможных дополнительных проверок данных фактов. Так же при её выполнении я задался вопросом: насколько часто можно создавать максимально вместительные предикаты, так как изначально проверка на выполнение заданных кандидатами условий  проводилась через один предикат, но по техническим пречинам его пришлось разбить на шесть. Так же это навело меня на мысли о необходимости таких предикатов, ведь если один большой, но универсальный работает не корректно и требует довольно точно поданных данных, а следовательно большего числа проверок, а шесть гораздо меньших по "мощи" предикатов и требующих меньшие проверки работают гораздо лучше, то гораздо удобнее дробить задачу на как можно большее количество мелких подзадач, которые гораздо удобнее контролировать, а объёмные предикаты стараться использовать как можно реже, а даже если и использовать, то сводить их к проверке других, более мелких предикатов.



